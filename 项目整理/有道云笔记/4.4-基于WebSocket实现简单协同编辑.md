### Main target

+ 实现协同编辑
+ 实时通信问题
+ 编辑冲突问题



## 01. 实时协同编辑

### 协同编辑

+ 协同编辑
  + 允许多个人在不同的计算机上编辑同一篇文档
  + 根据协同时效性分为：实时协同编辑 和 非实时协同编辑
+ 非实时协同编辑
  + 用户在本地分别完成编辑，然后上传到服务器实现协同
  + 在编辑时看不到对方的结果
  + 容易产生冲突，可以用 diff - patch 方法合并冲突

### 实时协同编辑

> 多个用户可以在同一时刻编辑同一篇文档，文档的内容实时更新变化

#### 实现实时协同编辑

+ 如何实现高效稳定的通信？
+ 如何保证文档的一致性？



## 02. 如何实现高效稳定的通信？

### 通信

+ 编辑器之间的实时通信
+ 编辑器与村吃服务器通信



### 实时通信

+ P2P 方式
+ C/S方式



### 通信协议

WebSocket协议



### 通信内容 - 基于状态

存在的问题：

+ 传输量大
+ 容易产生冲突
+ 冲突难以处理



### 通信内容 - 基于操作

优点

+ 传输量小
+ 不容易产生冲突
+ 冲突有办法解决



### 消息格式设计

```
insertText(0, 3, 'D')
```

```json
{
	"name": "insertText",
    "args"： "[0, 3, 'D']"
}
```

```js
{
    user: 'ALice'，
    fid: 'file007'，
    time: 7956886942，
    op: {
        "name": 'insertText'，
        "args": [0, 3, 'D']
    }
}
```

### 编辑器之间的实时通信

WebSocket



#### 思考

1. 连续输入文字，产生一系列需要传递的操作，是否可以优化？
2. 远端传入的操作，是否进入 undoStack?
3. 撤销和重做的操作，如何同步到远端执行？



### 与存储服务器的通信

存储服务器

+ 存储文档
+ 单向通信
+ HTTP协议



#### 加入协同



#### 协同服务器



#### 思考

1. 在编辑了很久之后新加入的编辑器，如何优化执行操作数？
2. 编辑器如果掉线了，协同服务如何知道？
3. 编辑器掉线之后重连，如何恢复同步？

#### 总结

协同服务器 （websocket 双向通信 传递操作 ）编辑器

编辑器 （http连接 单向通信 下载和上传文档） 存储服务器



## 03. 如何保证文档的一致性？



#### 解决冲突

+ 编辑锁
+ OT算法



### 编辑锁

#### 编辑锁

+ 参考数据库 共享锁 的概念
+ 用户修改文档之间枷锁
+ 加锁之后，其他用户只能读不能写

#### 段落锁

+ 参考数据库锁粒度的概念
+ 用户修改段落之前加锁
+ 加锁之后，其他用户不能修改该段落，但是可以修改其他段落
+ 用户点击其他段落，或者断开连接时，释放段落锁

存在的问题

+ 力度不够小，两个编辑者不能同时编辑同一个段落
+ 锁的管理实现起来也不容易



### OT算法

> Operational Transformation
>
> 已经是非常成熟的解决一致性问题的算法

应用：Google Docs等

+ ot.js
+ 纯文本，只有retain，insert和delete三个操作
+ sharedb   github.com/share/sharedb
+ 支持多种格式的JSON数据，且有插件机制可以自行拓展



### 最后小结

+ 实时协同编辑
  + 概念、分类、问题
+ 实时通信问题
  + 编辑器之间的通信与存储服务通信
+ 解决冲突问题
  + 编辑冲突问题定义编辑锁和OT算法