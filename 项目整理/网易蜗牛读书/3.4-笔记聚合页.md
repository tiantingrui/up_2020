# 笔记聚合页

### Main target

+ Websocket与Stomp
+ 小程序中使用Stomp
+ 无限加载列表的内存优化



## 01. Websocket 与 Stomp

### 笔记聚合页

#### 主要功能：

+ 展示共读过程中所有人参与的笔记
+ 实时订阅共读过程中笔记数据的更新
+ 实时订阅共读过程中私信的接收



#### 核心需求之一：

**实时订阅数据源的更新**



#### Http的缺陷

传统HTTP在实时数据订阅类场景的弊端

+ 实时性低：依靠轮询，不能及时获取最新的数据
+ 资源浪费：冗余请求过多，每次请求冗余的数据也较多
+ 同源限制：浏览器内对通信的服务来源也有限制



#### Websocket的优势

+ 实时性高：双向通信，可由服务端主动推送消息，适合订阅类场景
+ 数据轻量：连接建立后，传输的数据包头部更小
+ 无同源限制：浏览器对其并没有传统的同源限制
+ 多路复用：多个URI可以复用同一个Websocket连接



### STOMP over Websocket

#### 为什么要使用 STOMP over Websocket？

+ Websocket协议定义了两种类型的消息，文本和二进制，但他们的内容是未定义的
+ 通信的双方（B/S）需要有一套Websocket 之上的更高级的协议，这个协议定义了每次发送消息的类别，格式和内容
+ 这里我们选择在Websocket协议上使用STOMP协议来定义内容样式



#### 什么是STOMP

+ stomp （Simple (Or Streaming) Text Orientated Messaging Protocol）简单（流）文本定向消息协议
+ 定义了一种相互通信的数据格式，以便任何符合要求的stomp客户端都可以与任意stomp消息代理（Broker）进行交互



#### STOMP的优点

+ Websocket 对具体的各类场景 ，比如订阅-消费模式，并无明确的消息格式规范
+ 如果每个开发者面对这类场景时都需要自行定义通信文本的格式，会费时且不一定效果理想
+ Stomp为 订阅-消费场景提供了规范的消息格式，使开发者只需开发具体业务



## 02. 小程序中使用STOMP

### Stomp Over Websocket

+ 构建Stomp所需Websocket协议
+ 设置Stomp所需的心跳方法
+ 连接并订阅Stomp Server 



## 03. 无限列表的内存优化

### 面临的问题

#### 笔记聚合页：无限加载的长列表

+ **列表的每一项元素都较多**：包含icon、原文、笔记以及内部可无限展开的评论等，无限加载多页后占用内存过多，造成小程序崩溃
+ **列表的每一项高度不固定**：每条内部元素由用户笔记和评论组成，高度并不确定，传统的列表虚拟滚动方案大多要求列表项高度固定
+ **列表项浏览时经常会有快速的滚动**：移动端的使用场景，经常会快速的滚动列表，简单的基于滚动的实现方案可能不足以应对



### 实现思路

+ **Intersection Observer**

  使用基于视窗的 Intersection Observer API ，模拟设置更大的可见范围，应对快速滚动

+ **首次正常渲染**

  由于列表是分页加载的，单页内容占用的内存有限，可以令其每项在首次都正常渲染，使得每项的占用高度是自由的

+ **渲染后记录高度**

  首次或更改数据后触发的渲染，都把渲染后的高度记录在列表项上

+ **内存回收**

  正常渲染后再被滚动出视窗时，使用记录的高度撑开列表项，内部的元素清空，实现占用内存的回收



### 代码讲解

#### 无限加载列表

+  Intersection Observer API的使用
+ 列表项动态高度支持的实现思路
+ setData的性能优化意识



### 最后小结

+ Websocket 

  websocket在订阅常见下的优势

+ Stomp

  Stomp的应用意义和小程序中的接入方式

+ 长列表内存问题

  使用Intersection Obs-erver和其他设计解决高度不定列表项的内存回收优化

