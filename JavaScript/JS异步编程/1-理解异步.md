# 理解异步

**JavaScript异步编程**

### 目标：

+ 同步与异步
+ JavaScript单线程
+ 定时器



### 同步与异步

**同步**		调用之后得到结果，再干别的任务

**异步**		调用之后先不管结果，继续干别的任务

**单线程JS怎么实现异步？**

首先先来了解两个概念。

**进程**		是程序运行的实例，同一个程序可以产生多个进程，一个进程包含一个或多个线程

**线程**		操作系统能够进行运算调度的最小单位，一次只能执行一个任务，有自己的调用栈、寄存器环境，同一进程的线程共享进程资源

**Linux查看进程的常用命令**

```shell
ps,
process status
```

```shell
top,
table of process
```

**解决：**单线程的JS是**通过浏览器内核多线程实现异步**

### JavaScript单线程

#### 浏览器的进程（开源的Chromium）

+ 浏览器进程
+ 渲染进程（重点介绍）
+ GPU进程
+ 网络进程
+ 插件进程

**渲染进程**又有以下的线程

+ GUI线程

> 渲染布局（页面的html，css, js，构建DOM树和渲染树就是GUI线程的工作）

+ JS引擎线程

> 解析、执行JS程序  （chrome v8引擎），JS引擎线程只有一个，这也是为什么我们所说的js是单线程语言的原因，其实呢语言是没有单线程多线程之说的，因为解释这个语言的引擎是单线程的，所以我们说js是单线程的
>
> 与GUI互斥线程，因为js引擎线程也可以操作dom，这样会混乱
>
> 尽量控制js文件的大小，不要让js执行时间太长

+ 定时触发器线程

> setTimeout
>
> setInterval

+ 事件触发线程

> 将满足触发条件的事件放入任务队列（异步事件放入任务队列）

+ 异步HTTP请求线程

> 处理ajax请求的线程
>
> XHR所在线程
>
> 如果请求完成时有回调函数，它就会通知事件触发线程往任务队列里面添加事件

#### 前端的异步场景

+ 定时器
+ 网络请求
+ 事件绑定
+ ES6 Promise



### 定时器

#### 定时器的执行过程

> Event Loop

1. 主线程--执行栈（代码是在执行栈中执行）
2. web APIs--setTimeout（webAPi可以理解成浏览器提供的一种能力比如setTimeout）
3. 定时器线程--计时2s
4. 事件触发线程（事件触发线程将定时器事件放入任务队列）
5. 任务队列--异步任务

```html
顺序如下：
1.调用webApi(setTimeout)
2.定时器线程计数2s
3.事件触发线程将定时器事件放入任务队列（往执行栈中加任务）
4.主线程通过EventLoop遍历任务队列（往执行栈中出任务）
```

#### 定时器存在的问题

1. 定时任务可能不会按时执行(如果同步任务耗时很久的话，定时器任务不一定会及时执行)
2. 定时器嵌套5次之后最小间隔不能低于4ms

#### 定时器应用场景

+ 防抖
+ 节流
+ 倒计时
+ 动画（会存在丢帧的问题）

#### 定时器的应用

```js
//! for 循环是同步任务，所以等for 执行完之后才会去执行定时器这个异步任务, var作用域是全局的，没有块级作用域
for (var i = 1; i <= 10; i ++) {
    setTimeout(function() {
        console.log(i)
    }, 1000 * i)
}
```

```
for (var i = 1; i <= 10; i ++) {
    (function(i) {
        setTimeout(function() {
            console.log(i)
        }, 1000 * i)
    })(i)
}
```

```js
// ES6新增的let 块级作用域
for (let i = 1; i <= 10; i ++) {
    setTimeout(function() {
        console.log(i)
    }, 1000 * i)
}
```



#### 最后思考：

+ 浏览器采用多进程架构有什么优势和劣势
+ requestAnimationFrame实现动画比定时器有哪些优势
+ 整理定时器的思维导图







